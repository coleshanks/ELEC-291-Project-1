$NOLIST
$MODDE1SOC
$LIST

; Reset vector
org 0x0000
	ljmp MainProgram
		
DSEG at 30H
	x:   					ds 4
	y:   					ds 4
	bcd: 					ds 5
	temp_soak: 				ds 1
	time_soak: 				ds 1
	temp_refl: 				ds 1
	time_refl: 				ds 1
	temp_finish:			ds 1
	state:					ds 1
	temp_soak_FSM_Decimal: 	ds 1
BSEG
	mf: 					dbit 1	
CSEG
	; These 'equ' must match the wiring between the DE1-SoC board and the LCD!
	; P0 is in connector JP2.  Check "CV-8052 Soft Processor in the DE1-SoC Board: Getting
	; Started Guide" for the details.
	ELCD_RS equ P0.4
	ELCD_RW equ P0.5
	ELCD_E  equ P0.6
	ELCD_D4 equ P0.0
	ELCD_D5 equ P0.1
	ELCD_D6 equ P0.2
	ELCD_D7 equ P0.3
	
	UPDOWN_0	equ SWA.0
	UPDOWN_1 	equ SWA.1
	UPDOWN_2 	equ SWA.2
	UPDOWN_3 	equ SWA.3
	
$NOLIST
$include(LCD_4bit_DE1SoC.inc) ; A library of LCD related functions and utility macros
$LIST

$NOLIST
$include(math32.inc) ; A library of LCD related functions and utility macros
$LIST

	Initial_Message0:  db '1 ', 0
	Initial_Message1:  db 'TeS ', 0
	Initial_Message2:  db 'TiS ', 0
	Initial_Message3:  db 'TeR ', 0
	Initial_Message4:  db 'TiR ', 0

;                     1234567890123456    <- This helps determine the location of the counter
Initial_Message:  db 'Hello ', 0


MainProgram:
    mov SP, #0x7F
    mov P0MOD, #01111111b ; P0.0 to P0.6 are outputs.  ('1' makes the pin output)
    mov P1MOD, #00000011b ; P1.0 and P1.0 are outputs
    lcall ELCD_4BIT ; Configure LCD in four bit mode
	mov LEDRA, #0 ; LEDRA is bit addressable
    mov LEDRB, #0 ; LEDRB is NOT bit addresable
	

	mov temp_soak, 		#0x30
	mov time_soak, 		#0x05
	mov temp_refl,		#0x30
	mov time_refl, 		#0x20
	
	sjmp displayloop
	
displayloop:
	Set_Cursor(1,1)
	Send_Constant_String(#Initial_Message1)
	Set_Cursor(1,5)
	Display_BCD(temp_soak)
	mov x+0, temp_soak
	mov x+1, #0
	mov x+2, #0
	mov x+3, #0
	lcall hex2bcd2
	mov temp_soak_FSM_Decimal, y+0
	Set_Cursor(1,9)
	Send_Constant_String(#Initial_Message2)
	Set_Cursor(1,13)
	Display_BCD(time_soak)
	Set_Cursor(2,1)
	Send_Constant_String(#Initial_Message3)
	Set_Cursor(2,5)
	Display_BCD(temp_refl)
	Set_Cursor(2,9)
	Send_Constant_String(#Initial_Message4)
	Set_Cursor(2,13)
	Display_BCD(time_refl)
	sjmp check_temp_soak
	
check_temp_soak:
    jnb UPDOWN_3, check_time_soak 
	lcall wait_one_sec
	lcall wait_one_sec
set_temp_soak:
	mov a, temp_soak
	cjne a,#0x50, change_temp_soak
	mov a,#0x29
	mov temp_soak,a
change_temp_soak:
	add a, #0x01
	da a
	mov temp_soak,a

check_time_soak:
    jnb UPDOWN_1, check_temp_refl 
	lcall wait_one_sec
	lcall wait_one_sec
set_time_soak:
	mov a, time_soak
	cjne a, #0x20, change_time_soak
	mov a, #0x4
	mov time_soak, a
change_time_soak:
	add a, #0x01
	da a
	mov time_soak, a
	
check_temp_refl:;
    jnb UPDOWN_2, check_time_refl 
	lcall wait_one_sec
	lcall wait_one_sec
set_temp_refl:
	mov a, temp_refl
	cjne a, #0x40, change_temp_refl
	mov a, #0x19
	mov temp_refl, a
change_temp_refl:
	add a, #0x01
	da a
	mov temp_refl, a
	
check_time_refl:
	mov a, temp_soak_FSM_Decimal
	cjne a, #40, hop
	cpl LEDRA.0
hop:
    jnb UPDOWN_0, go_back_to_top 
	lcall wait_one_sec
	lcall wait_one_sec
set_time_refl:
	mov a, time_refl
	cjne a, #0x30, change_time_refl
	mov a, #0x9
	mov time_refl, a
change_time_refl:
	add a, #0x01
	da a
	mov time_refl, a
go_back_to_top:
	ljmp displayloop
	
wait_one_sec:
	Wait_Milli_Seconds(#250)
	ret
	
end
